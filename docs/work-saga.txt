1. Registrando as Sagas

Vou usar minhas próprias palavras para descrever cada método exposto pela API, se você quiser mais detalhes técnicos, você pode dar uma olhada na documentação nesse link.
Primeiramente, nós precisamos criar nosso saga generator e registrá-lo:
// rootSaga.js
function* rootSaga() {
  yield[
    fork(loadUser),
    takeLatest('LOAD_DASHBOARD', loadDashboardSequenced)
  ];
}
export default rootSaga;

Redux Saga expõe vários métodos chamados de Effects, e vamos usar vários deles:

fork(), realiza uma operação não bloqueante com a função passada
take(), pausa as operações até receber uma redux action
race(), executa Effects simultaneamente, e cancela todos quando um efeito retorna seu resultado
call(), executa uma função. Se essa função retornar uma Promise, ele irá pausar a Saga até a Promise ser resolvida
put(), despacha uma redux action
select(), executa uma função seletora que irá buscar dados do estado global do Redux
takeLatest(), irá executar as operações recebidas, porém, irá retornar apenas o valor da última. Se a mesma operação for enviada mais de uma vez, elas serão ignoradas, exceto a última (ex: click -> loadUser, usuário clica 4 vezes no botão (ele é legal né, quer testar sua app), apenas a função enviada no último click será executada/retornado o valor, as outras serão ignoradas)
takeEvery(), irá retornar os valores de todas as operações recebidas
No exemplo acima, nós registramos duas sagas diferentes (loadUser, loadDashboardSequenced), mas, iremos cria-las depois. Analisando o exemplo, nós estamos usando fork e takeLatest, onde takeLatest irá aguardar por uma ação chamada “LOAD_DASHBOARD” ser despachada pelo Redux para ser executada. (mais sobre isso no item 3)

2. Injetando o middleware das Sagas na Redux Store
Quando nós definimos nossa Redux Store, precisamos inicializar o middleware das Sagas:
import createSagaMiddleware from 'redux-saga'
import rootSaga from './rootSaga'
const sagaMiddleware = createSagaMiddleware();
const store = createStore(
  rootReducer,
  initialState,
  compose(
    applyMiddleware(sagaMiddleware)  
  );
);
sagaMiddleware.run(rootSaga);

3. Criando as Sagas
Vamos definir a Saga para loadUser:
function* loadUser() {
  try {
   // [1]
    const user = yield call(getUser);
   // [2]
    yield put({type: 'FETCH_USER_SUCCESS', payload: user});
  } catch(error) {
   // [3]
    yield put({type: 'FETCH_FAILED', error});
  }
}
Podemos ler o código acima dessa maneira:
[1] Fazemos a chamada para a função getUser, e guardamos o resultado na variável user
[2] Despachamos uma ação chamada FETCH_USER_SUCESS e passamos o valor user recebido na etapa anterior para ser consumido pelos reducers e guardado na store
[3] Se algo der errado, despachamos uma ação chamada FETCH_FAILED que avisar nossa aplicação que algo deu errado (aqui podemos mostrar uma mensagem de erro, etc)
Como você pode ver, a leitura é síncrona, mas as operações são assíncronas, só de poder usar yield e armazenar isso em uma variável, já vale a pena.
Agora, vamos criar a próxima Saga:
function* loadDashboardSequenced() {
  try {
    // [1]
    yield take(‘FETCH_USER_SUCCESS’);
    // [2]
    const user = yield select(state => state.user);
    // [3]
    const departure = yield call(loadDeparture, user);
    // [4]
    const flight = yield call(loadFlight, departure.flightID);
    const forecast = yield call(loadForecast, departure.date);
    // [5]
    yield put({
      type: ‘FETCH_DASHBOARD_SUCCESS’,
      payload: { forecast, flight, departure }
    });
  } catch (error) {
    // [6]
    yield put({
      type: ‘FETCH_FAILED’,
      error: error.message
    });
  }
}

Vamos ler da seguinte maneira:

[1] Esperamos para que uma redux action chamada FECTH_USER_SUCCESS seja despachada. Esse yield ficará na espera até essa ação ocorrer (veja mais sobre Effects no item 1).
[2] Selecionamos um valor da redux store. O efeito select recebe uma função que acessa a store. Nós armazenamos o resultado na constante user.
[3] Em seguida, executamos uma operação assíncrona para carregar as informações do voo, e passamos o objeto user como parâmetro para o efeito call
[4] Assim que a chamada assíncrona do loadDeparture for finalizada, nós executamos loadFlight com o objeto departure recebido na chamada anterior. O mesmo se aplica para a execução da função que busca dados do clima.
[5] Finalizando, após todas essas chamadas e funções serem resolvidas, nós usamos o efeito put para despachar uma ação na nossa aplicação, enviando todos os resultados de todas as chamadas assíncronas dessa Saga. Atualizando nosso estado global e enviando as atualizações para nossos reducers.

Como você pode ver, uma Saga é uma coleção de etapas que aguardam uma ação anterior para modificar seu comportamento. Quando finalizadas, todas as informações estão prontas para serem consumidas pela store.
Irado né?

Agora, vamos analisar um caso diferente. Vamos supor que getFlight e getForecast possam ser executadas ao mesmo tempo. Eles não precisam aguardar o resultado de um ou outro, então podemos pensar de outra maneira nesse caso:

* Sagas não bloqueantes

Para podermos executar duas operações não bloqueantes, nós precisamos modificar nosso código anterior:
function* loadDashboardNonSequenced() {
  try {
    // Esperando pela redux action
    yield take('FETCH_USER_SUCCESS');
    // Busca informações do usuário na store
    const user = yield select(getUserFromState);
    // Busca informações de embarque
    const departure = yield call(loadDeparture, user);
    
    // AQUI QUE A MÁGICA ACONTECE ??????
    const [flight, forecast] = yield [
        call(loadFlight, departure.flightID), 
        call(loadForecast, departure.date)
    ];
    // Retornando os valores para nossa aplicação
    yield put({
        type: 'FETCH_DASHBOARD_2_SUCCESS', 
        payload: { departure, flight, forecast }
    });
  } catch(error) {
    yield put({type: 'FETCH_FAILED', error: error.message});
  }
}

Precisamos registrar o yield como um Array:

const [flight, forecast] = yield [
    call(loadFlight, departure.flightID), 
    call(loadForecast, departure.date)
];

Agora, ambas as operações irão ocorrer em paralelo, mas no final do dia, teremos a certeza de que os dois resultados irão ser apresentado na nossa UI.
Agora, vamos registrar nossa Saga na função principal rootSaga:
function* rootSaga() {
  yield[
    fork(loadUser),
    takeLatest('LOAD_DASHBOARD', loadDashboardSequenced),
    takeLatest('LOAD_DASHBOARD2' loadDashboardNonSequenced)
  ];
}

Desse modo, todos os dados estarão disponíveis de uma vez no final da execução da Saga.
Mas, e se, ao invés de esperar todos os resultados, você quiser atualizar a UI toda vez que um dos resultados forem retornados?
Não se preocupe, tenho tudo resolvido aqui :)
Sagas não sequências e não bloqueantes
E aqui a brincadeira começa a ficar divertida, você pode isolar cada operação em uma Saga e depois combinar todas, ou seja, elas podem trabalhar independente uma da outras. E é exatamente isso que precisamos. Vamos dar uma olhada:
Etapa 1: Nós isolamos as sagas de Clima e Voo. E ambos dependem do resultado da saga de embarque.
// ====================
// Flight Saga
// ====================
function* isolatedFlight() {
  try {
    /* departure irá pegar o objeto enviado pelo efeito put */
    const departure = yield take('FETCH_DEPARTURE_3_SUCCESS');
 
    const flight = yield call(loadFlight, departure.flightID);
 
    yield put({type: 'FETCH_DASHBOARD_3_SUCCESS', payload: {flight}});
  } catch (error) {
    yield put({type: 'FETCH_FAILED', error: error.message});
  }
}
// ====================
// Forecast Saga
// ====================
function* isolatedForecast() {
    try {
     /* departure irá pegar o objeto enviado pelo efeito put */
     const departure = yield take('FETCH_DEPARTURE_3_SUCCESS');
     const forecast = yield call(loadForecast, departure.date);
     
     yield put({type: 'FETCH_DASHBOARD_3_SUCCESS', payload: { forecast, }});
} catch(error) {
      yield put({type: 'FETCH_FAILED', error: error.message});
    }
}
Percebeu algo bem importante aí? Nós iremos arquitetar nossas sagas dessa maneira:
Ambos precisam esperar pela mesma redux action chamada FETCH_DEPARTURE_3_SUCCESS ser despachada para começar a sua execução
Eles irão receber um valor quando essa ação for despachada. Mais sobre isso a seguir
Suas operações assíncronas serão executadas usando o efeito call e ambos irão executar o mesmo evento no final FETCH_DASHBOARD_3_SUCCESS. Mas ambos enviam diferentes dados para a nossa store. Graças ao poder do Redux, nós podemos fazer isso sem modificar nenhum reducer.
Etapa 2: Vamos alterar a Saga de embarque para que ele envie as ações corretas para as duas outras Sagas:
function* loadDashboardNonSequencedNonBlocking() {
  try {
    // Esperando pela redux action
    yield take('FETCH_USER_SUCCESS');
    // Busca informações do usuário na store
    const user = yield select(getUserFromState);
    // Busca informações de embarque
    const departure = yield call(loadDeparture, user);
    // Despacha uma ação para atualizar a UI
    yield put({type: 'FETCH_DASHBOARD3_SUCCESS', payload: { departure, }});
    // Despacha a ação necessária para a saga de Clima e Voo começarem...
    // Podemos passar um objeto no efeito put
    yield put({type: 'FETCH_DEPARTURE3_SUCCESS', departure});
  } catch(error) {
    yield put({type: 'FETCH_FAILED', error: error.message});
  }
}
Nada diferente até chegarmos ao efeito put no final. Nós podemos passar um objeto para a ação despachada e ele será enviado (yielded) para a variável departure nas sagas de voo e clima. Eu amo isso.
Você pode dar uma olhada no demo, e perceber como o terceiro painel carrega o clima antes do voo, porque o timeout dele é maior. Fazemos isso apenas para simular uma chamada lenta.
Em uma aplicação em produção, você provavelmente irá fazer algumas coisas diferentes. Eu só quero mostrar que é possível passar valores para o efeito put.
